const csstree = require('css-tree');
const testModuleName = require('../common-utils/testModuleName');

// Learn more about CSSTree at https://astexplorer.net/
// GitHub: https://github.com/csstree/csstree


function modifyCss(source, options) {
    const ast = csstree.parse(source);

    const {classPrefix, moduleClassPrefix, globalClass, hashClass, contextModuleName} = options;

    const allowedSet = new Set();

    csstree.walk(ast, function (node) {
        if (node.type === 'ClassSelector') {
            const isModule = /^[A-Z]/.test(node.name);

            if (!isModule) {
                if (classPrefix) {
                    node.name = classPrefix + node.name;
                }

                allowedSet.add(node.name);
                return;
            }

            const allowed = testModuleName(node.name, contextModuleName, options);

            if (moduleClassPrefix) {
                node.name = moduleClassPrefix + node.name;
            }

            if (classPrefix) {
                node.name = classPrefix + node.name;
            }

            if (allowed) {
                allowedSet.add(node.name);
            }
        }
    });

    if (globalClass || hashClass) {
        const hasClassSelector = node3 => csstree.find(node3, node4 =>
            node4.type === 'ClassSelector');

        const hasNotAllowedClass = node3 => csstree.find(node3, node4 =>
            node4.type === 'ClassSelector' && !allowedSet.has(node4.name));

        csstree.walk(ast, function(node) {
            // Start from Rule
            if (node.type === 'Rule') {
                if (node.prelude && node.prelude.type === 'SelectorList') {

                    // Loop through each Selector in SelectorList
                    // About IList: https://github.com/csstree/csstree/blob/master/lib/utils/List.js
                    node.prelude.children.forEachRight((node2) => {
                        if (node2.type === 'Selector') {
                            // We will separate Selector.children into selector-groups by slicing at WhiteSpace or Combinator (>, ~, +)
                            // we need to add global class and hash class to each selector-group
                            // Except the case:
                            // the selector-group contains module name class (start with uppercase alphabet character, /^[A-Z]/)
                            // AND that module name is not the name of the current module (options.contextModuleName)
                            // --> not allow
                            // This prevent allows we mention to a module class inside another module
                            // without modularizing that mentioned module
                            // we want to just keep the original selector in that case
                            // However, in the module itself, we still need to modularize it normally


                            // We support global selectors, those stay behind :global
                            // .comp-1 .comp-1x :global .skipped-1 .skipped-2 {}
                            // Remove the ":global" node from the result
                            // Every node behind the "alone" :global node will not be touched
                            let aloneGlobalIndex = null;
                            {
                                let index = -1;
                                node2.children.some((node3, cursor3, list3) => {
                                    index++;
                                    if ((node3.type === 'PseudoClassSelector' && node3.name === 'global')
                                        && (cursor3 === list3.head || ['WhiteSpace', 'Combinator'].includes(cursor3.prev.data.type))
                                        && (cursor3 === list3.tail || ['WhiteSpace', 'Combinator'].includes(cursor3.next.data.type))
                                    ) {
                                        aloneGlobalIndex = index;
                                        return true; // -> stop looping
                                    }
                                });
                            }

                            {
                                // Track with this variable
                                // when encountering separator or last node
                                // we will use it to decide that whether add global and hash classes or not
                                let allowed = false;
                                let anchor = null;


                                // Use forEachRight instead of forEach
                                // to avoid an infinite loop when adding a new node to the list
                                let index = node2.children.toArray().length;

                                node2.children.forEachRight((node3, cursor3, list3) => {
                                    index--;

                                    // Skip if in the "global range"
                                    if (aloneGlobalIndex !== null && index > aloneGlobalIndex) {
                                        return;
                                    }

                                    // Consider each node
                                    {
                                        const handleAllowed = (yes) => {
                                            if (allowed || anchor === null) {
                                                if (yes) {
                                                    if (anchor === null) {
                                                        allowed = true;
                                                    }
                                                } else {
                                                    allowed = false;
                                                }
                                            }

                                            if (anchor === null) {
                                                anchor = cursor3;
                                            }
                                        };

                                        if (node3.type === 'PseudoClassSelector' && node3.name === 'global') {
                                            handleAllowed(false);
                                        }
                                        else if (node3.type === 'PseudoClassSelector' && node3.children !== null) {
                                            handleAllowed(hasClassSelector(node3) && !hasNotAllowedClass(node3));
                                        }
                                        else if (node3.type === 'ClassSelector') {
                                            handleAllowed(allowedSet.has(node3.name));
                                        }
                                    }

                                    // Encounter separator or last node
                                    if (['WhiteSpace', 'Combinator'].includes(node3.type) || cursor3 === list3.head) {
                                        // If allowed to add classes
                                        if (allowed) {
                                            if (globalClass) {
                                                list3.insertData({
                                                    type: 'ClassSelector',
                                                    name: globalClass
                                                }, anchor.next);
                                            }

                                            if (hashClass) {
                                                list3.insertData({
                                                    type: 'ClassSelector',
                                                    name: hashClass
                                                }, anchor.next);
                                            }
                                        }

                                        // Reset for new turn
                                        allowed = false;
                                        anchor = null;
                                    }
                                });
                            }

                            node2.children = node2.children.filter((node3, cursor3, list3) => {
                                return !(node3.type === 'PseudoClassSelector' && node3.name === 'global');
                            });
                        }
                    });
                }
            }
        });
    }

    return csstree.generate(ast);
}


module.exports = modifyCss;
