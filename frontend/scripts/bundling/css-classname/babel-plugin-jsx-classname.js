const isExcluded = require('./common-utils/isExcluded');
const hashMap = require('./common-utils/hashMap');


module.exports = function() {
    return {
        visitor: {
            JSXAttribute(path, state) {
                if (path.node.name.name !== 'className') {
                    return;
                }

                if (isExcluded(state.filename, state.opts)) {
                    return;
                }

                const modifiers = getModifiers(state);

                // No changes in result
                // Supports array and object classname
                if (!modifiers.some(Boolean)) {
                    path.traverse({
                        JSXExpressionContainer(path1) {
                            if (path1.node !== path.node.value) {
                                return;
                            }

                            path1.traverse({
                                enter(path2) {
                                    if (path2.node !== path1.node.expression) {
                                        return;
                                    }

                                    path2.replaceWithSourceString(
                                        transformExpression(path2.node, path2.getSource()),
                                    );
                                    path2.skip();
                                },
                            });
                        },
                    });

                    return;
                }

                // Has changes in result
                {
                    path.traverse({
                        StringLiteral(path1) {
                            if (path1.node !== path.node.value) {
                                return;
                            }

                            path1.replaceWithSourceString(
                                transformStringLiteralWithChanges(path1.getSource(), modifiers),
                            );
                            path1.skip();
                        },
                        JSXExpressionContainer(path1) {
                            if (path1.node !== path.node.value) {
                                return;
                            }

                            path1.traverse({
                                enter(path2) {
                                    if (path2.node !== path1.node.expression) {
                                        return;
                                    }

                                    path2.replaceWithSourceString(
                                        transformExpression(path2.node, path2.getSource(), modifiers),
                                    );
                                    path2.skip();
                                },
                            });
                        },
                    });
                }
            },
        },
    };
};

function getModifiers(state) {
    const classPrefix = state.opts.classPrefix;
    const moduleClassPrefix = state.opts.moduleClassPrefix;
    const globalClass = state.opts.globalClass;
    const hashClass = hashMap.getValue(state.filename, state.opts);
    const globalAndHash = [globalClass, hashClass].filter(Boolean).join(' ');

    return [moduleClassPrefix, classPrefix, globalAndHash];
}

function transformStringLiteralWithChanges(snippet, [moduleClassPrefix, classPrefix, globalAndHash]) {
    return (
        '"'
        + snippet.slice(1, -1)
            .split(' ').map(t => t.trim()).filter(Boolean)
            .map(t => moduleClassPrefix && /^[A-Z]/.test(t) ? moduleClassPrefix + t : t)
            .map(t => classPrefix ? classPrefix + t : t)
            .concat(globalAndHash || [])
            .join(' ')
        + '"'
    );
}

function transformExpression(node, source, modifiers) {
    if (node.type === 'ObjectExpression') {
        return _transformClassnameObject(
            node, source, modifiers,
        );
    } else {
        return _transformClassnameCode(
            node, source, modifiers,
        );
    }
}

function _transformClassnameObject(node, source, modifiers) {
    const parts = [];

    node.properties.forEach(property => {
        const snippet = source.substring(
            property.value.start - node.start,
            property.value.end - node.start,
        );

        console.log(property.key.name, source);

        if (property.key.name === 'module') {
            parts.push(_transformClassnameCode(property.value, snippet, modifiers));
            return;
        }

        if (property.key.name === 'global') {
            parts.push(_transformClassnameCode(property.value, snippet));
            return;
        }
    });

    return parts.join(' + " " + ');
}

function _transformClassnameCode(node, snippet, modifiers) {
    if (!modifiers) {
        return _transformClassnameCodeNoChanges(node, snippet);
    }

    return _transformClassnameCodeWithChanges(node, snippet, modifiers);
}

function _transformClassnameCodeNoChanges(node, snippet) {
    if (node.type === 'ArrayExpression') {
        return (
            `${snippet}.filter(Boolean).join(' ')`
        );
    }

    return snippet;
}

function _transformClassnameCodeWithChanges(node, snippet, [moduleClassPrefix, classPrefix, globalAndHash]) {
    if (node.type === 'StringLiteral') {
        return (
            '"'
            + snippet.slice(1, -1)
                .split(' ').map(t => t.trim()).filter(Boolean)
                .map(t => moduleClassPrefix && /^[A-Z]/.test(t) ? moduleClassPrefix + t : t)
                .map(t => classPrefix ? classPrefix + t : t)
                .concat(globalAndHash || [])
                .join(' ')
            + '"'
        );
    }

    if (node.type === 'ArrayExpression') {
        return (
            `${snippet}.filter(Boolean)`
            + (moduleClassPrefix ? `.map(t => /^[A-Z]/.test(t) ? '${moduleClassPrefix}' + t : t)` : '')
            + (classPrefix ? `.map(t => '${classPrefix}' + t)` : '')
            + (globalAndHash ? `.concat('${globalAndHash}')` : '')
            + `.join(' ')`
        );
    }

    return (
        `(() => {`
        + `let s = (${snippet});`
        + `if (s) return s.split(' ').filter(Boolean)`
        + (moduleClassPrefix ? `.map(t => /^[A-Z]/.test(t) ? '${moduleClassPrefix}' + t : t)` : '')
        + (classPrefix ? `.map(t => '${classPrefix}' + t)` : '')
        + (globalAndHash ? `.concat('${globalAndHash}')` : '')
        + `.join(' '); `
        + (globalAndHash ? `return '${globalAndHash}';` : '')
        + `})()`
    );
}
