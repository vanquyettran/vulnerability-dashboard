import ResponseError from './ResponseError';
import { randomNumber } from '../utils/number';
import { translate } from '../i18n-core';
import Parcel from './Parcel';
import { hasOwnProperty } from 'libs/utils/object';


const options = {
    debug: false,
};

const listeningMap = new Map();

const uploadTrackingMap = new Map();

const downloadTrackingMap = new Map();

/**
 *
 * @param {string} type: final | progress
 * @param {Parcel} parcel
 * @param {function} callback
 * @param {Array} args
 * @private
 */
function __handleCallback(type: 'final' | 'progress', parcel: Parcel<any>, callback: (...args: any[]) => void, ...args: any[]) {
    if (!listeningMap.has(parcel)) {
        if (options.debug) {
            console.log('Received response for an abandoned parcel', parcel);
        }
        return;
    }

    if (type === 'final') {
        listeningMap.delete(parcel);
    }

    callback(...args);
}

function handleFinalCallback(parcel: Parcel<any>, callback: (...args: any[]) => void, ...args: any[]) {
    __handleCallback('final', parcel, callback, ...args);
}

function handleProgressCallback(parcel: Parcel<any>, callback: (...args: any[]) => void, ...args: any[]) {
    __handleCallback('progress', parcel, callback, ...args);
}

/**
 *
 * @param {Parcel} parcel
 * @return {string}
 */
function getXHRResponseType(parcel: Parcel<any>) {
    switch (parcel.getResponseContentFormat()) {
        case 'arrayBuffer':
            return 'arraybuffer'; // lowercase
        case 'blob':
            return 'blob';
        case 'text':
            return 'text';
        case 'json':
        default:
            return 'json';
    }
}

/**
 *
 * Make a request
 * The request might be queued caused by ConnectionsPerHostname of each browser
 * @param {Parcel} parcel
 * @return {Promise}
 */
function add<T>(parcel: Parcel<T>): Promise<T> {
    if (options.debug) {
        console.log('Sending parcel', parcel);
    }

    return new Promise<T>((resolve: (data: T) => void, reject) => {
        try {
            // Handle mockup requests
            // ----------------------

            if (parcel.getMode() !== 'Default') {
                const mockupData = parcel.parseResponseResult({ mockup: 1 }).data;

                switch (parcel.getMode()) {
                    case 'MockSuccessImmediately': {
                        listeningMap.set(parcel, () => undefined);
                        handleFinalCallback(parcel, () => resolve(mockupData as T));
                        break;
                    }
                    case 'MockSuccessDelay': {
                        const timer = setTimeout(() => {
                            handleFinalCallback(parcel, () => resolve(mockupData as T));
                        }, randomNumber(300, 800));
                        listeningMap.set(parcel, () => clearTimeout(timer));
                        break;
                    }
                }
                return;
            }

            // Handle real requests
            // --------------------

            const xhr = new XMLHttpRequest();

            listeningMap.set(parcel, () => xhr.abort());

            xhr.responseType = getXHRResponseType(parcel);

            xhr.open(parcel.getRequestMethod(), parcel.getRequestUrl());

            for (const key in parcel.requestHeaders) {
                if (hasOwnProperty(parcel.requestHeaders, key)) {
                    xhr.setRequestHeader(key, parcel.requestHeaders[key]);
                }
            }

            if (uploadTrackingMap.has(parcel)) {
                xhr.upload.onprogress = (event) => handleProgressCallback(parcel, uploadTrackingMap.get(parcel), event);
            }

            if (downloadTrackingMap.has(parcel)) {
                xhr.onprogress = (event) => handleProgressCallback(parcel, downloadTrackingMap.get(parcel), event);
            }

            xhr.onload = () => handleFinalCallback(parcel, () => {

                parcel.onResponse(xhr.response);

                const response = parcel.parseResponse(xhr.response);

                if (xhr.status >= 400) {
                    if (response === null || response === undefined) {
                        reject(new ResponseError(xhr.statusText));
                        return;
                    }

                    reject(parcel.parseResponseError(response));
                    return;
                }

                const responseResult = parcel.parseResponseResult(response);

                if (responseResult.error !== null) {
                    reject(responseResult.error);
                    return;
                }

                resolve(responseResult.data!);
            });

            xhr.onerror = () => handleFinalCallback(parcel, () => {
                reject(new ResponseError(xhr.statusText !== '' ? xhr.statusText : translate('Cannot connect to the server')));
            });

            xhr.onabort = () => handleFinalCallback(parcel, () => {
                reject(new ResponseError(xhr.statusText !== '' ? xhr.statusText : translate('The request was canceled')));
            });

            xhr.onloadend = () => {
                if (uploadTrackingMap.delete(parcel)) {
                    console.log('Released upload tracking on parcel', parcel);
                }

                if (downloadTrackingMap.delete(parcel)) {
                    console.log('Released download tracking on parcel', parcel);
                }
            };

            xhr.send(parcel.getRequestBody());

        } catch (error) {
            reject(new ResponseError((error as Error).message));
        }
    });
}

/**
 *
 * @param {...Parcel} parcels
 * @returns {Promise<Promise[]>}
 */
function parallel(...parcels: Parcel<any>[]) {
    return Promise.all(parcels.map(parcel => add(parcel)));
}

/**
 *
 * @param {Parcel} parcel
 */
function abandon(parcel: Parcel<any>) {
    listeningMap.delete(parcel);
}

/**
 *
 * @param {Parcel} parcel
 */
function destroy(parcel: Parcel<any>) {
    if (!listeningMap.has(parcel)) {
        return;
    }

    const abort = listeningMap.get(parcel);

    // 1st. Stop listening
    listeningMap.delete(parcel);

    // 2nd. Abort
    abort();

    if (options.debug) {
        console.log('Destroyed parcel', parcel);
    }
}

function trackUpload(parcel: Parcel<any>, callback: (...args: any[]) => void) {
    uploadTrackingMap.set(parcel, callback);
}

function trackDownload(parcel: Parcel<any>, callback: (...args: any[]) => void) {
    downloadTrackingMap.set(parcel, callback);
}

function setOption(key: keyof (typeof options), value: any) {
    if (hasOwnProperty(options, key)) {
        options[key] = value;
    }
}

export default {
    add,
    parallel,
    abandon,
    destroy,
    trackUpload,
    trackDownload,
    setOption,
};
