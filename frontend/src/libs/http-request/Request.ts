import ResponseError from "./ResponseError";
import {randomNumber} from "../utils/number";
import {translate} from "../i18n-core";


const options = {
    debug: false
};

const listeningMap = new Map();

const uploadTrackingMap = new Map();

const downloadTrackingMap = new Map();

/**
 *
 * @param {string} type: final | progress
 * @param {Parcel} parcel
 * @param {function} callback
 * @param {Array} args
 * @private
 */
function translatehandleCallback(type, parcel, callback, ...args) {
    if (!listeningMap.has(parcel)) {
        if (options.debug) {
            console.log('Received response for an abandoned parcel', parcel);
        }
        return;
    }

    if (type === 'final') {
        listeningMap.delete(parcel);
    }

    callback(...args);
}

function handleFinalCallback(parcel, callback, ...args) {
    translatehandleCallback('final', parcel, callback, ...args);
}

function handleProgressCallback(parcel, callback, ...args) {
    translatehandleCallback('progress', parcel, callback, ...args);
}

/**
 *
 * @param {Parcel} parcel
 * @return {string}
 */
function getXHRResponseType(parcel) {
    switch (parcel.getResponseContentFormat()) {
        case 'arrayBuffer':
            return 'arraybuffer'; // lowercase
        case 'blob':
            return 'blob';
        case 'text':
            return 'text';
        case 'json':
        default:
            return 'json';
    }
}

/**
 *
 * Make a request
 * The request might be queued caused by ConnectionsPerHostname of each browser
 * @param {Parcel} parcel
 * @return {Promise}
 */
function add(parcel) {
    if (options.debug) {
        console.log('Sending parcel', parcel);
    }

    return new Promise((resolve, reject) => {
        try {
            // Handle mockup requests
            // ----------------------

            if (parcel.getFakeMode() !== null) {
                const mockupData = parcel.parseResponseResult({mockup: 1}).getData();

                switch (parcel.getFakeMode()) {
                    case 'SUCCESS_IMMEDIATELY': {
                        listeningMap.set(parcel, () => undefined);
                        handleFinalCallback(parcel, () => resolve(mockupData));
                        break;
                    }
                    case 'SUCCESS_DELAY': {
                        const timer = setTimeout(() => {
                            handleFinalCallback(parcel, () => resolve(mockupData));
                        }, randomNumber(300, 800));
                        listeningMap.set(parcel, () => clearTimeout(timer));
                        break;
                    }
                    default:
                        throw new Error('Invalid fake mode: ' + parcel.getFakeMode());
                }
                return;
            }

            // Handle real requests
            // --------------------

            const xhr = new XMLHttpRequest();

            listeningMap.set(parcel, () => xhr.abort());

            xhr.responseType = getXHRResponseType(parcel);

            xhr.open(parcel.getRequestMethod(), parcel.getRequestUrl());

            for (let key in parcel.requestHeaders) {
                if (parcel.requestHeaders.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, parcel.requestHeaders[key]);
                }
            }

            if (uploadTrackingMap.has(parcel)) {
                xhr.upload.onprogress = (event) => handleProgressCallback(parcel, uploadTrackingMap.get(parcel), event);
            }

            if (downloadTrackingMap.has(parcel)) {
                xhr.onprogress = (event) => handleProgressCallback(parcel, downloadTrackingMap.get(parcel), event);
            }

            xhr.onload = () => handleFinalCallback(parcel, () => {

                parcel.onResponse(xhr.response);

                const response = parcel.parseResponse(xhr.response);

                if (xhr.status >= 400) {
                    if (!response) {
                        reject(new ResponseError(xhr.statusText));
                        return;
                    }

                    reject(parcel.parseResponseError(response));
                    return;
                }

                const responseResult = parcel.parseResponseResult(response);

                if (responseResult.getError() !== null) {
                    reject(responseResult.getError());
                    return;
                }

                resolve(responseResult.getData());
            });

            xhr.onerror = () => handleFinalCallback(parcel, () => {
                reject(new ResponseError(xhr.statusText || translate('Cannot connect to the server')));
            });

            xhr.onabort = () => handleFinalCallback(parcel, () => {
                reject(new ResponseError(xhr.statusText || translate('The request was canceled')));
            });

            xhr.onloadend = () => {
                if (uploadTrackingMap.delete(parcel)) {
                    console.log('Released upload tracking on parcel', parcel);
                }

                if (downloadTrackingMap.delete(parcel)) {
                    console.log('Released download tracking on parcel', parcel);
                }
            };

            xhr.send(parcel.getRequestBody());

        } catch (error) {
            reject(new ResponseError(error.message));
        }
    });
}

/**
 *
 * @param {...Parcel} parcels
 * @returns {Promise<Promise[]>}
 */
function parallel(...parcels) {
    return Promise.all(parcels.map(parcel => add(parcel)));
}

/**
 *
 * @param {Parcel} parcel
 */
function abandon(parcel) {
    listeningMap.delete(parcel);
}

/**
 *
 * @param {Parcel} parcel
 */
function destroy(parcel) {
    if (!listeningMap.has(parcel)) {
        return;
    }

    const abort = listeningMap.get(parcel);

    // 1st. Stop listening
    listeningMap.delete(parcel);

    // 2nd. Abort
    abort();

    if (options.debug) {
        console.log('Destroyed parcel', parcel);
    }
}

function trackUpload(parcel, callback) {
    uploadTrackingMap.set(parcel, callback);
}

function trackDownload(parcel, callback) {
    downloadTrackingMap.set(parcel, callback);
}

function setOption(key, value) {
    if (options.hasOwnProperty(key)) {
        options[key] = value;
    }
}

export default {
    add,
    parallel,
    abandon,
    destroy,
    trackUpload,
    trackDownload,
    setOption,
};
