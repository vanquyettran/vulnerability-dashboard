function wrapText(text, font, lineHeight, maxWidth, maxHeight, etc = '...') {
    let canvas = window.document.createElement('canvas');
    let ctx = canvas.getContext('2d');
    ctx.font = font;
    lineHeight = parseInt(lineHeight) || 0;
    if (!(lineHeight > 0)) {
        lineHeight = ctx.measureText('##').width;
    }

    const lines = text.split('\n');
    const newLines = [];
    lines.forEach(line => {
        if (line.trim().length > 0) {
            let words = line.split(/(\s+)/);
            let newWords = [];
            words.forEach(word => {
                let newWord = '';
                word.split('').forEach(char => {
                    let tryNewWord = newWord + char;
                    let tryNewWordWidth = ctx.measureText(tryNewWord).width;
                    if (tryNewWordWidth > maxWidth && newWord.length > 0) {
                        newWords.push(newWord);
                        newWord = char;
                    } else {
                        newWord = tryNewWord;
                    }
                });
                if (newWord.length > 0) {
                    newWords.push(newWord);
                }
            });
            let newLine = '';
            newWords.forEach(word => {
                let tryNewLine = newLine ? (newLine + word) : word;
                let tryNewLineWidth = ctx.measureText(tryNewLine).width;
                if (tryNewLineWidth > maxWidth && newLine.length > 0) {
                    newLines.push(newLine);
                    newLine = word;
                } else {
                    newLine = tryNewLine;
                }
            });
            if (newLine.length > 0) {
                newLines.push(newLine);
            }
        } else {
            newLines.push(line);
        }
    });

    // remove 1 (only one) whitespace before linebreak character,
    // or after if the before is not a whitespace
    for (let i = 0; i < newLines.length; i++) {
        const thisLastChar = newLines[i].charAt(newLines[i].length - 1);
        if (thisLastChar === ' ') {
            newLines[i] = newLines[i].slice(0, -1);
        }
        else if (i < newLines.length - 1) { // this is not last line
            const nextFirstChar = newLines[i + 1].charAt(0);
            if (nextFirstChar === ' ') {
                newLines[i + 1] = newLines[i + 1].slice(1);
            }
        }
    }

    let maxLineWidth = 0;
    newLines.forEach(line => {
        let lineWidth = ctx.measureText(line).width;
        if (lineWidth > maxLineWidth) {
            maxLineWidth = lineWidth;
        }
    });

    let newLines2 = [];
    if (maxHeight && maxHeight > 0) {
        newLines.forEach((line, index) => {
            if ((index + 1) * lineHeight <= maxHeight) {
                if (newLines[index + 1] && (index + 2) * lineHeight > maxHeight) {
                    while (line !== '' && ctx.measureText(line + etc).width > maxWidth) {
                        line = line.slice(0, -1);
                    }
                    line += etc;
                }
                newLines2.push(line);
            }
        });
    } else {
        newLines2 = newLines;
    }

    return {lines: newLines2, lineHeight: lineHeight, maxLineWidth: maxLineWidth};
}

export {
    wrapText
}
