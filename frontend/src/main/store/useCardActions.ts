import {useSetRecoilState} from 'recoil';
import {cardData} from './atoms';
import {
    AjaxAction,
    AjaxState,
    CardDataManipulation,
    EntityDataManipulationInternal,
} from 'main/store/interfaces';
import useAjaxList from 'main/store/ajax-actions/useAjaxList';
import useAjaxRead from 'main/store/ajax-actions/useAjaxRead';
import useAjaxCreate from 'main/store/ajax-actions/useAjaxCreate';
import useAjaxUpdate from 'main/store/ajax-actions/useAjaxUpdate';
import useAjaxDraftUpdate from 'main/store/ajax-actions/useAjaxDraftUpdate';
import useAjaxDelete from 'main/store/ajax-actions/useAjaxDelete';
import manipulateData from 'main/store/manipulateData';
import {useState} from 'react';
import ResponseError from 'libs/http-request/ResponseError';
import __ from 'main/i18n';
import Request from 'libs/http-request/Request';
import Card from 'main/models/interfaces/Card';

export default function useCardActions(): CardDataManipulation {
    const {addOrReplace, update, removeById, reorder} = manipulateData(useSetRecoilState(cardData));

    return {
        ajaxList: useAjaxList(addOrReplace),
        ajaxRead: useAjaxRead(addOrReplace),
        ajaxCreate: useAjaxCreate(addOrReplace),
        ajaxUpdate: useAjaxUpdate(update),
        ajaxDraftUpdate: useAjaxDraftUpdate(update),
        ajaxDelete: useAjaxDelete(removeById),
        ajaxDraftMigrate: useAjaxDraftMigrate(update, reorder),
    };
}

function useAjaxDraftMigrate(
    update: EntityDataManipulationInternal<Card>['update'],
    reorder: EntityDataManipulationInternal<Card>['reorder'],
): AjaxAction<{card: Card, posInList: number}> {
    const [state, setState] = useState<AjaxState>({inProgress: false, error: null});

    const run: CardDataManipulation['ajaxDraftMigrate']['run'] = (parcel) => {
        if (state.inProgress) {
            return Promise.reject(new ResponseError(__('The process is running')));
        }

        const draftData = parcel.getExpectedResponseData();
        if (draftData === null) {
            return Promise.reject(new ResponseError(__('No expected response data')));
        }

        const {card, posInList} = draftData;

        return new Promise((resolve, reject) => {
            update(card, (fallback, data) => {
                if (fallback === null) {
                    return reject(new ResponseError(__('Entity not found with ID ::id', {id: card.id})));
                }

                const fallbackGlobalPos = data.allIds.indexOf(card.id);

                const globalPosIfSameList = (() => {
                    const listCards = data.allIds
                        .map(id => data.byId[id])
                        .filter(t => t.listId === card.listId);

                    if (listCards.length === 0) {
                        return 0;
                    }

                    if (posInList > listCards.length - 1) {
                        const lastCardInList = listCards[listCards.length - 1];
                        const globalPosOfLastCardInList = data.allIds.indexOf(lastCardInList.id);
                        return globalPosOfLastCardInList + 1;
                    }

                    {
                        const refCardInList = listCards[posInList];
                        return data.allIds.indexOf(refCardInList.id);
                    }
                })();

                const globalPos = (() => {
                    if (fallback.listId === card.listId) {
                        return globalPosIfSameList;
                    }

                    // Moving left will not affect the order like in the same list
                    if (fallbackGlobalPos > globalPosIfSameList) {
                        return globalPosIfSameList;
                    }

                    // If not in the same list and move right then
                    // all indexes after the source index will be decreased 1
                    return globalPosIfSameList - 1;
                })();

                // Cannot call 2 setters (update and reorder) in the same stack
                requestAnimationFrame(() => {
                    reorder(card.id, globalPos);
                    setState({inProgress: true, error: null});

                    Request.add(parcel)
                        .then((entity) => {
                            setState({inProgress: false, error: null});
                            resolve(entity);
                        })
                        .catch(error => {
                            setState({inProgress: false, error: error});
                            update(fallback);
                            reorder(card.id, fallbackGlobalPos);
                            reject(error);
                        });
                });

            });
        });
    };

    return {run, state};
}
