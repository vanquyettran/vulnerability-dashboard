import {useSetRecoilState} from 'recoil';
import {cardData} from '../__internals/atoms';
import {AjaxAction, AjaxState, CardDataManipulation} from 'main/store/interfaces';
import useAjaxList from '../__internals/ajax-actions/useAjaxList';
import useAjaxRead from '../__internals/ajax-actions/useAjaxRead';
import useAjaxCreate from '../__internals/ajax-actions/useAjaxCreate';
import useAjaxUpdate from '../__internals/ajax-actions/useAjaxUpdate';
import useAjaxDraftUpdate from '../__internals/ajax-actions/useAjaxDraftUpdate';
import useAjaxDelete from '../__internals/ajax-actions/useAjaxDelete';
import manipulateData from '../__internals/manipulateData';
import {useState} from 'react';
import ResponseError from 'libs/http-request/ResponseError';
import __ from 'main/i18n';
import Request from 'libs/http-request/Request';
import {CardMoveParams} from 'main/api/card/CardMoveParcel';

type UpdateAndReorder = (
    draftData: CardMoveParams,
    callback?: (fallback: CardMoveParams | null) => void,
) => void;

export default function useCardActions(): CardDataManipulation {
    const {addOrReplace, update, removeById, setData} = manipulateData(useSetRecoilState(cardData));

    const updateAnReorder: UpdateAndReorder = ({card, posInList}, callback) => {
        setData(data => {
            if (!(card.id in data.byId)) {
                if (callback !== undefined) {
                    callback(null);
                }
                return data;
            }

            const allCards = data.allIds.map(id => data.byId[id]);

            // Fallback
            const fallbackCard = data.byId[card.id];
            const fallbackCardsInList = allCards.filter(t => t.listId === fallbackCard.listId);
            const fallbackPosInList = fallbackCardsInList.map(t => t.id).indexOf(card.id);

            // Global positions
            const sourceGlobalPos = data.allIds.indexOf(card.id);
            const destGlobalPosIfSameList = (() => {
                const cardsInList = allCards.filter(t => t.listId === card.listId);

                if (cardsInList.length === 0) {
                    return 0;
                }

                if (posInList < 0) {
                    const firstCardInList = cardsInList[0];
                    return data.allIds.indexOf(firstCardInList.id);
                }

                if (posInList > cardsInList.length - 1) {
                    const lastCardInList = cardsInList[cardsInList.length - 1];
                    return data.allIds.indexOf(lastCardInList.id) + 1;
                }

                {
                    const refCardInList = cardsInList[posInList];
                    return data.allIds.indexOf(refCardInList.id);
                }
            })();
            const destGlobalPos = (() => {
                if (fallbackCard.listId === card.listId) {
                    return destGlobalPosIfSameList;
                }

                // Moving left will not affect the order like in the same list
                if (sourceGlobalPos >= destGlobalPosIfSameList) {
                    return destGlobalPosIfSameList;
                }

                // If not in the same list and move right then
                // all indexes after the source index will be decreased 1
                return destGlobalPosIfSameList - 1;
            })();

            // Reorder
            const reorderedIds = Array.from(data.allIds);
            const [removed] = reorderedIds.splice(sourceGlobalPos, 1);
            reorderedIds.splice(destGlobalPos, 0, removed);

            if (callback !== undefined) {
                callback({card: fallbackCard, posInList: fallbackPosInList});
            }

            return {
                byId: {
                    ...data.byId,
                    [card.id]: card,
                },
                allIds: reorderedIds,
            };
        });
    };

    return {
        ajaxList: useAjaxList(addOrReplace),
        ajaxRead: useAjaxRead(addOrReplace),
        ajaxCreate: useAjaxCreate(addOrReplace),
        ajaxUpdate: useAjaxUpdate(update),
        ajaxDraftUpdate: useAjaxDraftUpdate(update),
        ajaxDelete: useAjaxDelete(removeById),
        ajaxDraftMove: useAjaxDraftMove(updateAnReorder),
    };
}

function useAjaxDraftMove(updateAndReorder: UpdateAndReorder): AjaxAction<CardMoveParams> {
    const [state, setState] = useState<AjaxState>({inProgress: false, error: null});

    const run: CardDataManipulation['ajaxDraftMove']['run'] = (parcel) => {
        if (state.inProgress) {
            return Promise.reject(new ResponseError(__('The process is running')));
        }

        const draftData = parcel.getExpectedResponseData();
        if (draftData === null) {
            return Promise.reject(new ResponseError(__('No expected response data')));
        }

        return new Promise((resolve, reject) => {
            updateAndReorder(draftData, (fallback) => {
                if (fallback === null) {
                    return reject(new ResponseError(__('Entity not found with ID ::id', {id: draftData.card.id})));
                }

                setState({inProgress: true, error: null});

                Request.add(parcel)
                    .then((entity) => {
                        setState({inProgress: false, error: null});
                        resolve(entity);
                    })
                    .catch(error => {
                        setState({inProgress: false, error: error});
                        updateAndReorder(fallback);
                        reject(error);
                    });
            });
        });
    };

    return {run, state};
}
