import {Dispatch, SetStateAction, useCallback} from 'react';
import Entity from 'main/models/interfaces/Entity';
import {EntityDataSource, EntityDataManipulationInternal} from 'main/store/interfaces';

export default function manipulateData<T extends Entity>(
    setData: Dispatch<SetStateAction<EntityDataSource<T>>>,
): EntityDataManipulationInternal<T> {

    const addOrReplace = useCallback((...entities: T[]) => {
        if (entities.length === 0) {
            return;
        }

        setData(data => {
            const _byId: typeof data.byId = {};
            const _allIds: typeof data.allIds = [];

            for (const entity of entities) {
                _byId[entity.id] = entity;

                if (!(entity.id in data.byId)) {
                    _allIds.push(entity.id);
                }
            }

            return {
                byId: {...data.byId, ..._byId},
                allIds: [...data.allIds, ..._allIds],
            };
        });
    }, [setData]);

    const removeById = useCallback((entityId: T['id']) => {
        setData(data => {
            if (!(entityId in data.byId)) {
                return data;
            }

            const {[entityId]: _, ...newById} = data.byId;
            const newAllIds = data.allIds.filter(id => id !== entityId);

            return {
                byId: newById,
                allIds: newAllIds,
            };
        });
    }, [setData]);

    const update = useCallback<EntityDataManipulationInternal<T>['update']>((entity, callback) => {
        setData(data => {
            if (!(entity.id in data.byId)) {
                if (callback !== undefined) {
                    callback(null);
                }
                return data;
            }

            if (callback !== undefined) {
                callback(data.byId[entity.id]);
            }

            return {
                byId: {
                    ...data.byId,
                    [entity.id]: entity,
                },
                allIds: data.allIds,
            };
        });
    }, [setData]);

    const swap: EntityDataManipulationInternal<T>['swap'] = (aId, bId) => {
        setData(data => {
            const startIndex = data.allIds.indexOf(aId);
            const endIndex = data.allIds.indexOf(bId);
            if (startIndex < 0 || endIndex < 0 || startIndex === endIndex) {
                return data;
            }

            const newOrderedAllIds = Array.from(data.allIds);
            const [removed] = newOrderedAllIds.splice(startIndex, 1);
            newOrderedAllIds.splice(endIndex, 0, removed);

            return {
                byId: data.byId,
                allIds: newOrderedAllIds,
            };
        });
    };

    const reorder: EntityDataManipulationInternal<T>['reorder'] = (entityId, newPosition) => {
        setData(data => {
            const currentPosition = data.allIds.indexOf(entityId);
            if (currentPosition === -1) {
                return data;
            }
            console.log('---', entityId, newPosition);
            console.log(data.allIds);
            const reorderedIds = Array.from(data.allIds);
            const [removed] = reorderedIds.splice(currentPosition, 1);
            if (currentPosition < newPosition) {
                reorderedIds.splice(newPosition - 1, 0, removed);
            } else {
                reorderedIds.splice(newPosition, 0, removed);
            }
            console.log(reorderedIds);
            return {
                byId: data.byId,
                allIds: reorderedIds,
            };
        });
    };

    return {
        addOrReplace,
        update,
        removeById,
        swap,
        reorder,
    };
}
