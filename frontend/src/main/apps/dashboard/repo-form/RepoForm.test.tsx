import React, {useState} from 'react';
import {render, waitFor} from '@testing-library/react';
import RepoForm from './RepoForm';
import __ from 'main/i18n';
import userEvent from '@testing-library/user-event/dist';
import useRepoActions from 'main/store/repo/useRepoActions';
import createDraftRepo from 'main/models/factory/createDraftRepo';
import RepoCreateParcel from 'main/api/repo/RepoCreateParcel';
import IRepo from 'main/models/interfaces/IRepo';
import Request, {MOCK_DEFAULT} from 'libs/http-request/Request';
import ResponseError from 'libs/http-request/ResponseError';
import AppProvider from 'main/AppProvider';

function MyTestComponent({repo, onSuccess, onError, onCancel}: {
    repo: IRepo,
    onSuccess?: (repo: IRepo) => void,
    onError?: (error: ResponseError) => void,
    onCancel?: () => void,
}) {
    const repoActions = useRepoActions();
    const [draftRepo, setDraftRepo] = useState(repo);
    const parcel = new RepoCreateParcel(draftRepo);

    return (
        <RepoForm
            action={repoActions.ajaxCreate}
            parcel={parcel}
            values={draftRepo}
            setValues={setDraftRepo}
            onSuccess={onSuccess}
            onError={onError}
            onCancel={onCancel}
        />
    );
}

describe('<RepoForm/>', () => {
    const myRender = () => {
        const repo = createDraftRepo({name: 'blo bla'});
        const onSuccess = jest.fn();
        const onError = jest.fn();
        const onCancel = jest.fn();

        const screen = render(
            <AppProvider>
                <MyTestComponent
                    repo={repo}
                    onSuccess={onSuccess}
                    onError={onError}
                    onCancel={onCancel}
                />
            </AppProvider>,
        );

        return {screen, repo, onSuccess, onError, onCancel};
    };

    it('renders form', async () => {
        const {screen, onSuccess, onError, onCancel} = myRender();

        const textarea = screen.getByPlaceholderText(__('Enter repo name')) as HTMLTextAreaElement;
        expect(textarea).toBeInTheDocument();

        userEvent.type(textarea, ' elsa');
        expect(textarea).toHaveValue('blo bla elsa');

        const saveButton = screen.getByTitle(__('Save'));
        expect(saveButton).toBeInTheDocument();

        // 1 API create repo + 4 APIs create lists
        Request.setTestMockQueue(new Error(), MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT);
        userEvent.click(saveButton);
        await waitFor(() => {
            expect(onError).toBeCalled();
        });

        Request.setTestMockQueue(MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT);
        userEvent.click(saveButton);
        await waitFor(() => {
            expect(onSuccess).toBeCalled();
        }, {timeout: 100});

        userEvent.type(textarea, ' alice');

        Request.setTestMockQueue(MOCK_DEFAULT, new Error(), new Error(), new Error(), new Error());
        userEvent.click(saveButton);
        await waitFor(() => {
            expect(onSuccess).toBeCalled();
        });

        userEvent.type(textarea, ' bob');

        Request.setTestMockQueue(MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT, MOCK_DEFAULT, new Error());
        userEvent.click(saveButton);
        await waitFor(() => {
            expect(onSuccess).toBeCalled();
        }, {timeout: 100});

        const cancelButton = screen.getByTitle(__('Cancel'));
        expect(cancelButton).toBeInTheDocument();

        userEvent.click(cancelButton);
        expect(onCancel).toBeCalled();

    });
});
