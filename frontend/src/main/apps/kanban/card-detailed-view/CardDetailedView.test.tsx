import React, {useEffect, useRef} from 'react';
import CardDetailedView from 'main/apps/kanban/card-detailed-view/CardDetailedView';
import {render, RenderResult, waitFor} from '@testing-library/react';
import TestProvider from 'main/TestProvider';
import useListData from 'main/store/list/useListData';
import useCardData from 'main/store/card/useCardData';
import useCardActions from 'main/store/card/useCardActions';
import useRepoActions from 'main/store/repo/useRepoActions';
import RepoCreateParcel from 'main/api/repo/RepoCreateParcel';
import CardCreateParcel from 'main/api/card/CardCreateParcel';
import createDraftRepo from 'main/models/factory/createDraftRepo';
import ICard from 'main/models/interfaces/ICard';
import createDraftCard from 'main/models/factory/createDraftCard';
import Request, {MockDefault} from 'libs/http-request/Request';
import __ from 'main/i18n';
import userEvent from '@testing-library/user-event/dist';
import {act} from 'react-dom/test-utils';

function MyTestComponent({cardRef, onClose}: {cardRef: {current: ICard | null}, onClose: () => void}) {
    const repoActions = useRepoActions();
    const cardActions = useCardActions();
    const listData = useListData();
    const cardData = useCardData();

    useEffect(() => {
        repoActions.ajaxCreate.run(new RepoCreateParcel(
            createDraftRepo({name: 'doraemon'}),
        ));
    }, []);

    const isCardCreationCalled = useRef(false);

    useEffect(() => {
        if (listData.entities.length === 4) {
            if (!isCardCreationCalled.current) {
                isCardCreationCalled.current = true;
                cardActions.ajaxCreate.run(new CardCreateParcel(
                    createDraftCard({
                        text: 'nobita',
                        listId: listData.entities[0].id,
                    }),
                ));
            }
        }
    }, [listData, isCardCreationCalled.current]);

    const card = cardData.entities[0];

    if (!card) {
        return <span>Generating testing data...</span>;
    }

    cardRef.current = card;

    return (
        <CardDetailedView
            cardId={card.id}
            listId={card.listId}
            onClose={onClose}
        />
    );
}


describe('<CardDetailedView/>', () => {
    const refs: {
        screen: RenderResult,
        selectBox: HTMLSelectElement,
    } = {screen: null!, selectBox: null!};

    const cardRef: {current: ICard} = {current: null!};

    const onClose = jest.fn();

    const getOptionsAsString = () => {
        return Array.from(refs.selectBox.options).map(option => {
            return option.textContent;
        }).join('|');
    };

    const getLog = (index: number) => {
        const log = cardRef.current.activityLog[index];

        return refs.screen.queryByText(__('Moved from ::from to ::to at ::timestamp(DATE)', {
            from: log.fromListTitle,
            to: log.toListTitle,
            timestamp: log.timestamp,
        }));
    };

    const getSelectedOption = () => {
        return Array.from(refs.selectBox.options).find(option => {
            return option.selected;
        })?.textContent;
    };

    beforeEach(async () => {
        await act(async () => {
            Request.setTestMockQueue(
                MockDefault,               // Create repo
                MockDefault,               // Create list 1
                MockDefault,               // Create list 2
                MockDefault,               // Create list 3
                MockDefault,               // Create list 4
                MockDefault,               // Create card
                MockDefault,               // Move to Confirmed
                MockDefault,               // Move to Fixed
            );

            const screen = render(
                <TestProvider>
                    <MyTestComponent cardRef={cardRef} onClose={onClose}/>
                </TestProvider>,
            );
            refs.screen = screen;

            expect(screen.queryByText('Generating testing data...')).toBeInTheDocument();

            await waitFor(() => {
                expect(screen.queryByText('Generating testing data...')).not.toBeInTheDocument();
            });


            const selectBox = screen.queryByLabelText(__('Status')) as HTMLSelectElement;
            refs.selectBox = selectBox;

            expect(selectBox).toBeInTheDocument();
            expect(getOptionsAsString()).toBe('Open|Confirmed|False Positive|Fixed');
            expect(getSelectedOption()).toBe('Open');
        });
    });

    it('moves from Open > Confirmed > Fixed', async () => {
        await act(async () => {
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'Confirmed');

            await waitFor(() => {
                expect(screen.queryByText(__('Activity log'))).toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(1);
                expect(getLog(0)).toBeInTheDocument();
                expect(getOptionsAsString()).toBe('Confirmed|Fixed');
            });

            userEvent.selectOptions(selectBox, 'Fixed');

            await waitFor(() => {
                expect(cardRef.current.activityLog.length).toBe(2);
                expect(getLog(1)).toBeInTheDocument();
                expect(getOptionsAsString()).toBe('Fixed');
            });
        });
    });

    it('moves from Open > False Positive', async () => {
        await act(async () => {
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'False Positive');

            await waitFor(() => {
                expect(screen.queryByText(__('Activity log'))).toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(1);
                expect(getLog(0)).toBeInTheDocument();
                expect(getOptionsAsString()).toBe('False Positive');
            });
        });
    });

    it('moves from Open > Fixed', async () => {
        await act(async () => {
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'Fixed');

            await waitFor(() => {
                expect(screen.queryByText(__('Activity log'))).toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(1);
                expect(getLog(0)).toBeInTheDocument();
                expect(getOptionsAsString()).toBe('Fixed');
            });
        });
    });

    it('clicks on close button', () => {
        const {screen} = refs;

        const closeBtn = screen.getByTitle(__('Close'));

        userEvent.click(closeBtn);

        expect(onClose).toBeCalledTimes(1);
    });
});
