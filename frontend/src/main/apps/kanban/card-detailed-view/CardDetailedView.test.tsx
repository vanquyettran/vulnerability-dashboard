import React, {useEffect, useRef} from 'react';
import CardDetailedView from './CardDetailedView';
import {render, RenderResult, waitFor} from '@testing-library/react';
import TestProvider from 'main/TestProvider';
import useListData from 'main/store/list/useListData';
import useCardData from 'main/store/card/useCardData';
import useCardActions from 'main/store/card/useCardActions';
import useRepoActions from 'main/store/repo/useRepoActions';
import RepoCreateParcel from 'main/api/repo/RepoCreateParcel';
import CardCreateParcel from 'main/api/card/CardCreateParcel';
import createDraftRepo from 'main/models/factory/createDraftRepo';
import ICard from 'main/models/interfaces/ICard';
import createDraftCard from 'main/models/factory/createDraftCard';
import Request, {MockDefault} from 'libs/http-request/Request';
import __ from 'main/i18n';
import userEvent from '@testing-library/user-event/dist';
import {act} from 'react-dom/test-utils';

function MyTestComponent({cardRef, onClose}: {cardRef: {current: ICard | null}, onClose: () => void}) {
    const repoActions = useRepoActions();
    const cardActions = useCardActions();
    const listData = useListData();
    const cardData = useCardData();

    useEffect(() => {
        repoActions.ajaxCreate.run(new RepoCreateParcel(
            createDraftRepo({name: 'doraemon'}),
        ));
    }, []);

    const isCardCreationCalled = useRef(false);

    useEffect(() => {
        if (listData.entities.length === 4) {
            if (!isCardCreationCalled.current) {
                isCardCreationCalled.current = true;
                cardActions.ajaxCreate.run(new CardCreateParcel(
                    createDraftCard({
                        text: 'nobita',
                        listId: listData.entities[0].id,
                    }),
                ));
            }
        }
    }, [listData, isCardCreationCalled.current]);

    const card = cardData.entities[0];

    if (!card) {
        return <span>Generating testing data...</span>;
    }

    cardRef.current = card;

    return (
        <CardDetailedView
            cardId={card.id}
            listId={card.listId}
            onClose={onClose}
        />
    );
}


describe('<CardDetailedView/>', () => {
    const refs: {
        screen: RenderResult,
        selectBox: HTMLSelectElement,
    } = {screen: null!, selectBox: null!};

    const cardRef: {current: ICard} = {current: null!};

    const onClose = jest.fn();

    const getOptionsAsString = () => {
        return Array.from(refs.selectBox.options).map(option => {
            return option.textContent;
        }).join('|');
    };

    const getLog = (index: number) => {
        const log = cardRef.current.activityLog[index];

        return refs.screen.queryByText(__('Moved from ::from to ::to at ::timestamp(DATE)', {
            from: log.fromListTitle,
            to: log.toListTitle,
            timestamp: log.timestamp,
        }));
    };

    const getSelectedOption = () => {
        return Array.from(refs.selectBox.options).find(option => {
            return option.selected;
        })?.textContent;
    };

    beforeEach(async () => {
        await act(async () => {
            Request.setTestMockQueue(
                MockDefault,               // Create repo
                MockDefault,               // Create list Open
                MockDefault,               // Create list Confirmed
                MockDefault,               // Create list False Positive
                MockDefault,               // Create list Fixed
                MockDefault,               // Create card
            );

            const screen = render(
                <TestProvider>
                    <MyTestComponent cardRef={cardRef} onClose={onClose}/>
                </TestProvider>,
            );
            refs.screen = screen;

            expect(screen.queryByText('Generating testing data...')).toBeInTheDocument();

            await waitFor(() => {
                expect(screen.queryByText('Generating testing data...')).not.toBeInTheDocument();
            });


            const selectBox = screen.queryByLabelText(__('Status')) as HTMLSelectElement;
            refs.selectBox = selectBox;

            expect(selectBox).toBeInTheDocument();
            expect(getOptionsAsString()).toBe('Open|Confirmed|False Positive|Fixed');
            expect(getSelectedOption()).toBe('Open');
        });
    });

    it('moves from Open > Confirmed > Fixed', async () => {
        await act(async () => {
            Request.setTestMockQueue(MockDefault, MockDefault);
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'Confirmed');

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Confirmed');
                expect(getOptionsAsString()).toBe('Confirmed|Fixed');
                expect(screen.queryByText(__('Activity log'))).toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(1);
                expect(getLog(0)).toBeInTheDocument();
            });

            userEvent.selectOptions(selectBox, 'Fixed');

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Fixed');
                expect(getOptionsAsString()).toBe('Fixed');
                expect(cardRef.current.activityLog.length).toBe(2);
                expect(getLog(1)).toBeInTheDocument();
            });
        });
    });

    it('moves from Open > False Positive', async () => {
        await act(async () => {
            Request.setTestMockQueue(MockDefault);
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'False Positive');

            await waitFor(() => {
                expect(getSelectedOption()).toBe('False Positive');
                expect(getOptionsAsString()).toBe('False Positive');
                expect(screen.queryByText(__('Activity log'))).toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(1);
                expect(getLog(0)).toBeInTheDocument();
            });
        });
    });

    it('moves from Open > Fixed', async () => {
        await act(async () => {
            Request.setTestMockQueue(MockDefault);
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'Fixed');

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Fixed');
                expect(getOptionsAsString()).toBe('Fixed');
                expect(screen.queryByText(__('Activity log'))).toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(1);
                expect(getLog(0)).toBeInTheDocument();
            });
        });
    });

    it('moves from Open > Confirmed failed', async () => {
        await act(async () => {
            Request.setTestMockQueue(new Error('Failed to move to Confirmed!'));
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'Confirmed');

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Confirmed');
            });

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Open');
                expect(screen.queryByText('Failed to move to Confirmed!')).toBeInTheDocument();
                expect(screen.queryByText(__('Activity log'))).not.toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(0);
            });
        });
    });

    it('moves from Open > Fixed failed', async () => {
        await act(async () => {
            Request.setTestMockQueue(new Error('Failed to move to Fixed!'));
            const {screen, selectBox} = refs;

            userEvent.selectOptions(selectBox, 'Fixed');

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Fixed');
            });

            await waitFor(() => {
                expect(getSelectedOption()).toBe('Open');
                expect(screen.queryByText('Failed to move to Fixed!')).toBeInTheDocument();
                expect(screen.queryByText(__('Activity log'))).not.toBeInTheDocument();
                expect(cardRef.current.activityLog.length).toBe(0);
            });
        });
    });

    it('add notes', async () => {
        const {screen} = refs;
        const textarea = screen.getByPlaceholderText(__('Add notes...'));
        expect(textarea).toBeInTheDocument();

        Request.setTestMockQueue(MockDefault);
        userEvent.type(textarea, 'Alibaba Tiki Lazada{Enter}Canada Australia Myanmar');
        textarea.blur();

        await waitFor(() => {
            expect(textarea.textContent).toBe('Alibaba Tiki Lazada\nCanada Australia Myanmar');
        });

        Request.setTestMockQueue(new Error('Cannot save your changes'));
        userEvent.type(textarea, '{Enter}blo bla');
        textarea.blur();

        expect(textarea.textContent).toBe('Alibaba Tiki Lazada\nCanada Australia Myanmar\nblo bla');

        await waitFor(() => {
            expect(screen.queryByText('Cannot save your changes')).toBeInTheDocument();
            expect(textarea.textContent).toBe('Alibaba Tiki Lazada\nCanada Australia Myanmar');
        });
    });

    it('clicks on close button', () => {
        const {screen} = refs;
        const closeBtn = screen.getByTitle(__('Close'));
        userEvent.click(closeBtn);
        expect(onClose).toBeCalledTimes(1);
    });
});
