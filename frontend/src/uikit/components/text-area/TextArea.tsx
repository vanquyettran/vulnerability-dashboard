import './TextArea.less';
import React, {forwardRef, Ref, useEffect, useRef, useState} from 'react';
import {wrapText} from 'libs/utils/text';

export interface TextAreaProps {
    value: string,
    setValue: (value: string) => void,
    placeholder?: string,
    rows?: number,
    minRows?: number,
    multipleLines?: boolean,
    autoFocus?: boolean,
    disabled?: boolean,
    readOnly?: boolean,
    autoGrow?: boolean,
    onFocus?: React.EventHandler<React.FocusEvent<HTMLTextAreaElement>>,
    onBlur?: React.EventHandler<React.FocusEvent<HTMLTextAreaElement>>,
}

export default forwardRef(function TextArea(
    {
        value,
        setValue,
        placeholder,
        rows = undefined,
        minRows = 0,
        multipleLines = false,
        autoFocus = false,
        disabled = false,
        readOnly = false,
        onFocus = () => undefined,
        onBlur = () => undefined,
    }: TextAreaProps,
    ref: Ref<HTMLDivElement>,
) {
    const [focused, setFocused] = useState(false);

    const handleChange: React.EventHandler<React.ChangeEvent<HTMLTextAreaElement>> = (ev) => {
        if (multipleLines) {
            setValue(ev.target.value);
        } else {
            setValue(ev.target.value.replace(/\n/g, ''));
        }
    };

    const handleKeydown: React.EventHandler<React.KeyboardEvent<HTMLTextAreaElement>> = (ev) => {
        if (ev.key === 'Enter') {
            if (!multipleLines) {
                ev.preventDefault();
                const target = ev.target as HTMLTextAreaElement;
                target.blur();
                const form = target.form;
                if (form !== null) {
                    const submitButton = form.querySelector(
                        'button[type="submit"], input[type="submit"]',
                    ) as HTMLButtonElement | HTMLInputElement;

                    if (submitButton !== null) {
                        submitButton.click();
                    }
                }
            }
        }
    };

    const inputRef = useRef<HTMLTextAreaElement>(null);

    useEffect(() => {
        if (inputRef.current !== null && autoFocus) {
            inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            inputRef.current.focus();
        }
    }, []);

    const autoGrow = rows === undefined || rows <= 0;
    const [numRows, setNumRows] = useState(Math.max(minRows, autoGrow ? 1 : rows));


    const updateNumRows = () => {
        if (inputRef.current === null) {
            return;
        }
        const style = window.getComputedStyle(inputRef.current);
        const maxWidth = inputRef.current.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
        try {
            const {lines} = wrapText(value, style.font, style.lineHeight, maxWidth, null);
            setNumRows(Math.max(minRows, lines.length));
        } catch (e) {
            console.warn(e);
        }
    };

    useEffect(() => {
        if (autoGrow) {
            updateNumRows();
        }
    }, [autoGrow, value]);

    useEffect(() => {
        if (autoGrow) {
            requestAnimationFrame(() => {
                updateNumRows();
            });
        }
    }, []);

    return (
        <div
            className={[
                'TextArea',
                value === '' && 'empty',
                focused && 'focused',
                disabled && 'disabled',
                readOnly && 'read-only',
                autoGrow && 'auto-grow',
            ]}
            ref={ref}
        >
            <textarea
                style={{
                    height: ''
                }}
                value={value}
                onChange={handleChange}
                onKeyDown={handleKeydown}
                onFocus={(ev) => {
                    setFocused(true);
                    onFocus(ev);
                }}
                onBlur={(ev) => {
                    setFocused(false);
                    onBlur(ev);
                }}
                placeholder={placeholder}
                rows={numRows}
                disabled={disabled || readOnly}
                ref={inputRef}
            />
        </div>
    );
});
