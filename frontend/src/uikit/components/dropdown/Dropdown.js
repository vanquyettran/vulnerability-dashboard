import './Dropdown.less';
import React from 'react';
import {
    addRelationBetweenElements,
    removeRelationBetweenElements,
    getClientElementsInRelation,
    getHostElementsInRelation,
    RELATION_DROPDOWN_ANCHOR,
    RELATION_ADOPTED_CHILD,
} from "../../dom/element/relations";
import {setClickAwayListener, unsetClickAwayListener} from '../../dom/event-handling/click-away';
import DocumentPortal from '../document-portal/DocumentPortal';
import {font_size, line_height, space} from 'theme/_vars';


export default class Dropdown extends React.PureComponent {
    constructor(props) {
        super(props);

        this.state = {
            contentViewableMaxHeight: -1
        };

        /**
         *
         * @type {HTMLDivElement}
         */
        this.dropdown = null;

        /**
         *
         * @type {HTMLDivElement}
         */
        this.pointer = null;

        this.clickAwayId = Symbol();

        /**
         *
         * @type {function[]}
         */
        this.eventUnsubscribers = [];
    }

    componentDidMount() {
        this.setAdoptionRelations();
        this.setClickOutsideEventListener();
        this.setResizeEventListener();
        this.setScrollEventListeners();
        this.refreshDisplay();
    }

    componentWillUnmount() {
        this.unsubscribeAllEvents();
    }

    componentDidUpdate() {
        this.refreshDisplay();
    }

    unsubscribeAllEvents = () => {
        this.eventUnsubscribers.forEach(fn => fn());
    };

    addEventUnsubscriber = (fn) => {
        if (!this.eventUnsubscribers.includes(fn)) {
            this.eventUnsubscribers.push(fn);
        }
    };

    setAdoptionRelations = () => {
        const adoptedChildren = [this.dropdown, this.pointer].filter(Boolean);

        adoptedChildren.forEach(el => {
            addRelationBetweenElements(RELATION_ADOPTED_CHILD, this.getAnchorElement(), el);
        });

        this.addEventUnsubscriber(() => {
            adoptedChildren.forEach(el => {
                removeRelationBetweenElements(RELATION_ADOPTED_CHILD, this.getAnchorElement(), el);
            });
        });
    };

    setClickOutsideEventListener = () => {
        setClickAwayListener(
            this.clickAwayId,
            [this.dropdown, this.pointer, this.getOpenerElement()].filter(Boolean),
            () => this.close()
        );

        this.addEventUnsubscriber(() => {
            unsetClickAwayListener(this.clickAwayId);
        });
    };

    setResizeEventListener = () => {
        window.addEventListener('resize', this.refreshDisplay);

        this.addEventUnsubscriber(() => {
            window.removeEventListener('resize', this.refreshDisplay);
        });
    };

    setScrollEventListeners = () => {
        /**
         * @type {HTMLElement}
         */
        const anchor = this.getAnchorElement();

        const addListener = (obj) => {
            obj.addEventListener('scroll', this.refreshDisplay);

            this.addEventUnsubscriber(() => {
                obj.removeEventListener('scroll', this.refreshDisplay);
            });
        };

        /**
         *
         * @param {HTMLElement} el
         */
        const check = (el) => {
            const style = window.getComputedStyle(el);

            if (style.overflowY === 'auto' || style.overflowY === 'scroll' || style.overflowX === 'auto' || style.overflowX === 'scroll') {
                addListener(el);
            }
        };

        let loops = 1e5;

        /**
         *
         * @param {HTMLElement} el
         * @param {boolean} isInit
         */
        const backtick = (el, isInit) => {
            if (!el) {
                return;
            }

            if (!isInit) {
                check(el);
            }

            if (--loops < 0) {
                console.error('Maximum chained nodes exceeded. Make sure to avoid circular relations.');
                return;
            }

            if (el.parentElement) {
                backtick(el.parentElement, false);
            }

            getClientElementsInRelation(RELATION_DROPDOWN_ANCHOR, el).forEach(anchor => {
                backtick(anchor, false);
            });

            getHostElementsInRelation(RELATION_ADOPTED_CHILD, el).forEach(host => {
                backtick(host, false);
            });
        };

        backtick(anchor, true);

        addListener(window);
    };

    dispatchOnRefreshDisplay = () => {
        const {onRefreshDisplay} = this.props;

        onRefreshDisplay && onRefreshDisplay();
    };

    close = () => {
        this.props.close();
    };

    refreshDisplay = () => {
        if (this.dropdown === null) {
            return;
        }

        const dr = this.getDropdownRect();
        const op = this.getAnchorRect();
        const fr = this.getFrameRect();

        // Close due to zero size of anchor element
        if (op.width === 0 && op.height === 0) {
            this.close();
            return;
        }

        this.updateDimensions(dr, op, fr);

        requestAnimationFrame(() => {
            if (this.dropdown === null) {
                return;
            }

            const dr = this.getDropdownRect();
            const op = this.getAnchorRect();
            const fr = this.getFrameRect();
            this.updatePosition(dr, op, fr);
            this.dispatchOnRefreshDisplay();
        });

    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updateDimensions = (dr, op, fr) => {
        this.updateWidth(dr, op, fr);
        this.updateContentViewableMaxHeight(dr, op, fr);
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updateWidth = (dr, op, fr) => {
        const {width, minWidth, maxWidth} = this.props;

        const apply = (name, value) => {
            if (value === 'anchorWidth') {
                this.setDropdownStyle(name, op.width + 'px');
                return;
            }

            if (value === 'frameWidth') {
                this.setDropdownStyle(name, (fr.width - 2 * this.getEdgeMargin()) + 'px');
                return;
            }

            if (typeof value === 'number') {
                this.setDropdownStyle(name, value + 'px');
                return;
            }

            if (typeof value === 'string') {
                this.setDropdownStyle(name, value);
                return;
            }
        };

        [
            ['width', width],
            ['minWidth', minWidth],
            ['maxWidth', maxWidth]
        ].map(([name, value]) => apply(name, value));
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updateContentViewableMaxHeight = (dr, op, fr) => {
        const dropdownStyle = window.getComputedStyle(this.dropdown);
        const padding = (
            parseFloat(dropdownStyle.paddingTop) +
            parseFloat(dropdownStyle.paddingBottom) +
            parseFloat(dropdownStyle.borderTopWidth) +
            parseFloat(dropdownStyle.borderBottomWidth)
        );

        const contextMaxHeight = Math.max(
            this.calcMaxHeightAbove(dr, op, fr),
            this.calcMaxHeightBelow(dr, op, fr)
        );

        const newContentViewableMaxHeight = Math.max(
            this.getContentMinHeight(),
            Math.min(this.getMaxHeightLimit(fr), contextMaxHeight) - padding
        );

        const {contentViewableMaxHeight} = this.state;
        if (Math.abs(newContentViewableMaxHeight - contentViewableMaxHeight) > 2) {
            this.setState({
                contentViewableMaxHeight: newContentViewableMaxHeight
            });
        }
    };

    /**
     *
     * @param {ClientRect} fr
     */
    getMaxHeightLimit = (fr) => {
        const {desiredMaxHeightLimit} = this.props;

        if (desiredMaxHeightLimit === null) {
            return Number.MAX_SAFE_INTEGER;
        }

        return Math.min(
            fr.height - 2 * this.getEdgeMargin(),
            Math.max(
                desiredMaxHeightLimit,
                fr.height / 2
            )
        );
    };

    getContentMinHeight = () => {
        return 4 * font_size.body * line_height.body;
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updatePosition = (dr, op, fr) => {
        this.updatePositionX(dr, op, fr);
        this.updatePositionY(dr, op, fr);
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updatePositionX = (dr, op, fr) => {
        this.updateDropdownPositionX(dr, op, fr);

        if (this.pointer) {
            this.updatePointerPositionX(dr, op, fr);
        }
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updateDropdownPositionX = (dr, op, fr) => {
        const {horizontalAlignment} = this.props;

        if (horizontalAlignment === 'right') {
            this.updateDropdownPositionRight(dr, op, fr);
            return;
        }

        this.updateDropdownPositionLeftOrCenter(dr, op, fr);
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updateDropdownPositionLeftOrCenter = (dr, op, fr) => {
        const {horizontalAlignment} = this.props;

        const minDropdownLeft = fr.left + this.getContextEdgeMarginLeft(op);
        const maxDropdownLeft = fr.right - dr.width - this.getContextEdgeMarginRight(op, fr);

        const defaultDropdownLeft = horizontalAlignment === 'center'
            ? op.left + op.width / 2 - dr.width / 2
            : op.left;

        const dropdownLeft = Math.max(minDropdownLeft, Math.min(maxDropdownLeft, defaultDropdownLeft));

        this.setDropdownStyle('left', dropdownLeft + 'px');
        this.setDropdownStyle('right', 'auto');
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updateDropdownPositionRight = (dr, op, fr) => {
        const minDropdownRight = this.getContextEdgeMarginRight(op, fr);
        const maxDropdownRight = fr.width - dr.width - this.getContextEdgeMarginLeft(op);

        const defaultDropdownRight = fr.right - op.right;
        const dropdownRight = Math.max(minDropdownRight, Math.min(maxDropdownRight, defaultDropdownRight));

        this.setDropdownStyle('right', dropdownRight + 'px');
        this.setDropdownStyle('left', 'auto');
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updatePointerPositionX = (dr, op, fr) => {
        const pointerLeft = this.calcPointerLeft(dr, op, fr);

        if (pointerLeft < this.getEdgeMargin() || pointerLeft > fr.right - this.getPointerSize() - this.getEdgeMargin()) {
            this.setPointerStyle('display', 'none');
        } else {
            this.setPointerStyle('display', 'block');
            this.setPointerStyle('left', pointerLeft + 'px');
        }
    };

    /**
     *
     * @param {ClientRect} op
     */
    getContextEdgeMarginLeft = (op) => {
        return Math.max(this.getOverflowEdgeMargin(), Math.min(this.getEdgeMargin(), op.left));
    };

    /**
     *
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    getContextEdgeMarginRight = (op, fr) => {
        return Math.max(this.getOverflowEdgeMargin(), Math.min(this.getEdgeMargin(), fr.width - op.right));
    }

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    calcPointerLeft = (dr, op, fr) => {
        return op.left + op.width / 2 - this.getPointerSize() / 2;
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    updatePositionY = (dr, op, fr) => {
        if (this.shouldDropBelow(dr, op, fr)) {
            this.setDropdownBelow(dr, op, fr);

            if (this.pointer) {
                this.setPointerBelow(dr, op, fr);
            }

            return;
        }

        this.setDropdownAbove(dr, op, fr);

        if (this.pointer) {
            this.setPointerAbove(dr, op, fr);
        }
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    setPointerBelow = (dr, op, fr) => {
        this.setPointerStyle('top', (op.bottom + this.getDropMargin() - this.getPointerSize() / 2) + 'px');
        this.pointer.setAttribute('data-direction', 'up');
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    setPointerAbove = (dr, op, fr) => {
        this.setPointerStyle('top', (op.top - this.getDropMargin() - this.getPointerSize() / 2) + 'px');
        this.pointer.setAttribute('data-direction', 'down');
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    setDropdownBelow = (dr, op, fr) => {
        const dropMargin = this.getDropMargin();
        this.setDropdownStyle('top', (op.bottom + dropMargin) + 'px');
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    setDropdownAbove = (dr, op, fr) => {
        const dropMargin = this.getDropMargin();
        this.setDropdownStyle('top', (op.top - dr.height - dropMargin) + 'px');
    };

    shouldDropBelow = (dr, op, fr) => {
        const freeSpaceBelow = this.calcFreeSpaceBelow(dr, op, fr);
        const freeSpaceAbove = this.calcFreeSpaceAbove(dr, op, fr);

        const {desiredDropDirection} = this.props;

        switch (desiredDropDirection) {
            case 'up':
                if (freeSpaceAbove >= 0) {
                    return false;
                }
                if (freeSpaceBelow >= 0) {
                    return true;
                }
                return !(freeSpaceAbove >= freeSpaceBelow);

            case 'down':
            default:
                if (freeSpaceBelow >= 0) {
                    return true;
                }
                if (freeSpaceAbove >= 0) {
                    return false;
                }
                return freeSpaceBelow >= freeSpaceAbove;
        }
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    calcMaxHeightAbove = (dr, op, fr) => {
        const dropMargin = this.getDropMargin();
        const edgeMargin = this.getEdgeMargin();

        return op.top - (fr.top + dropMargin + edgeMargin);
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    calcMaxHeightBelow = (dr, op, fr) => {
        const dropMargin = this.getDropMargin();
        const edgeMargin = this.getEdgeMargin();

        return fr.bottom - (op.bottom + dropMargin + edgeMargin);
    };


    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    calcFreeSpaceAbove = (dr, op, fr) => {
        return this.calcMaxHeightAbove(dr, op, fr) - dr.height;
    };

    /**
     *
     * @param {ClientRect} dr
     * @param {ClientRect} op
     * @param {ClientRect} fr
     */
    calcFreeSpaceBelow = (dr, op, fr) => {
        return this.calcMaxHeightBelow(dr, op, fr) - dr.height;
    };

    getDropMargin = () => {
        const {dropMargin} = this.props;

        if (this.pointer) {
            return dropMargin + this.getPointerCross() / 2;
        }

        return dropMargin;
    };

    getEdgeMargin = () => {
        const {edgeMargin} = this.props;

        return edgeMargin;
    };

    getOverflowEdgeMargin = () => {
        return 0;
    }

    getPointerSize = () => {
        const {pointerSize} = this.props;

        return pointerSize;
    };

    getPointerCross = () => {
        return this.getPointerSize() * Math.sqrt(2);
    };

    /**
     *
     * @param {string} name
     * @param {string|number} value
     */
    setDropdownStyle = (name, value) => {
        this.dropdown.style[name] = value;
    };

    /**
     *
     * @param {string} name
     * @param {string|number} value
     */
    setPointerStyle = (name, value) => {
        this.pointer.style[name] = value;
    };

    /**
     *
     * @return {ClientRect}
     */
    getAnchorRect = () => {
        const anchor = this.getAnchorElement();

        return anchor.getBoundingClientRect();
    };

    /**
     *
     * @return {ClientRect}
     */
    getFrameRect = () => {
        return {
            top: 0,
            left: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            width: window.innerWidth,
            height: window.innerHeight
        };
    };

    /**
     *
     * @return {ClientRect}
     */
    getDropdownRect = () => {
        return this.dropdown.getBoundingClientRect();
    };

    getAnchorElement = () => {
        return this.props.anchor || this.props.opener;
    };

    getOpenerElement = () => {
        return this.props.opener;
    };

    render = () => {
        const {children, hasPointer, horizontalAlignment, appearance, overflow} = this.props;
        const {contentViewableMaxHeight} = this.state;

        return <DocumentPortal>
            <div
                className={[
                    'Dropdown',
                    'appearance-' + appearance,
                    'horizontal-align-' + horizontalAlignment,
                ]}
                style={{
                    display: 'block',
                    position: 'fixed',
                    overflow: overflow,
                }}
                ref={el => {
                    if (el === null) return;

                    this.dropdown = el;
                    addRelationBetweenElements(RELATION_DROPDOWN_ANCHOR, this.dropdown, this.getAnchorElement());
                }}
            >
                {
                    typeof children === 'function'
                        ? children(contentViewableMaxHeight, this.refreshDisplay)
                        : children
                }
            </div>
            {
                hasPointer &&
                <div
                    className={[
                        'Dropdown__pointer',
                        'appearance-' + appearance,
                        'horizontal-align-' + horizontalAlignment,
                    ]}
                    style={{
                        display: 'block',
                        position: 'fixed',
                        transform: 'rotate(45deg)',
                        width: this.getPointerSize() + 'px',
                        height: this.getPointerSize() + 'px',
                    }}
                    ref={el => this.pointer = el}
                />
            }
        </DocumentPortal>;
    };
}


Dropdown.defaultProps = {
    opener: null,
    anchor: null,
    width: null, // null | number | string | 'anchorWidth' | 'frameWidth'
    minWidth: null, // null | number | string | 'anchorWidth' | 'frameWidth'
    maxWidth: 'frameWidth', // null | number | string | 'anchorWidth' | 'frameWidth'
    desiredDropDirection: 'down', // 'down' | 'up'
    hasPointer: false,
    pointerSize: space.small_1,
    dropMargin: space.tiny_3,
    edgeMargin: space.medium_1,
    horizontalAlignment: 'left',
    appearance: 'default', // 'default' | 'tooltip-hard' | 'tooltip-soft'
    onRefreshDisplay: null,
    desiredMaxHeightLimit: 400,
    overflow: 'hidden',
    close: () => undefined,
};
