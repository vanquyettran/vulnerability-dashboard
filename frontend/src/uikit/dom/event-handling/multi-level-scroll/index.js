import {
    getClientElementsInRelation,
    getHostElementsInRelation,
    RELATION_ADOPTED_CHILD,
    RELATION_DROPDOWN_ANCHOR,
} from '../../element/relations';

/**
 *
 * @type {Map<HTMLElement, Map<function, Array<HTMLElement>>>}
 */
const STORE = new Map();

function addListeners(scrollEl, owner, callback) {
    scrollEl.addEventListener('scroll', callback);

    if (!STORE.has(owner)) {
        STORE.set(owner, new Map());
    }

    const map = STORE.get(owner);

    if (!map.has(callback)) {
        map.set(callback, []);
    }

    const scrollElements = map.get(callback);

    if (!scrollElements.includes(owner)) {
        scrollElements.push(owner);
    }
}

export function removeMultiLevelScrollListener(owner, callback) {
    const map = STORE.get(owner);
    if (!map) {
        return;
    }

    const scrollElements = map.get(callback);
    if (!scrollElements) {
        return;
    }

    scrollElements.forEach(scrollEl => {
        scrollEl.removeEventListener('scroll', callback);
    });

    map.delete(callback);

    if (map.size === 0) {
        STORE.delete(owner);
    }
}

export function addMultiLevelScrollListener(owner, callback) {
    if (!(owner instanceof HTMLElement)) {
        console.error('`node` must be instance of HTMLElement');
        return;
    }

    /**
     *
     * @param {HTMLElement} el
     */
    const check = (el) => {
        const style = window.getComputedStyle(el);

        if (style.overflowY === 'auto' || style.overflowY === 'scroll' || style.overflowX === 'auto' || style.overflowX === 'scroll') {
            addListeners(el, owner, callback);
        }
    };

    let loops = 1e5;

    /**
     *
     * @param {HTMLElement} el
     * @param {boolean} isInit
     */
    const backtick = (el, isInit) => {
        if (!el) {
            return;
        }

        if (!isInit) {
            check(el);
        }

        if (--loops < 0) {
            console.error('Maximum chained nodes exceeded. Make sure to avoid circular relations.');
            return;
        }

        if (el.parentElement) {
            backtick(el.parentElement, false);
        }

        getClientElementsInRelation(RELATION_DROPDOWN_ANCHOR, el).forEach(anchor => {
            backtick(anchor, false);
        });

        getHostElementsInRelation(RELATION_ADOPTED_CHILD, el).forEach(host => {
            backtick(host, false);
        });
    };

    backtick(owner, true);

    addListeners(window, owner, callback);
}
